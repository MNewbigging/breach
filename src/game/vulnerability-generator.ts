export type VulnerabilitySpec =
  | { type: "exact-length"; exactLength: number }
  | { type: "vowel-exact"; vowelCount: number }
  | { type: "vowel-min"; minVowels: number }
  | { type: "sum"; sum: number }
  | { type: "at-least-AM"; minAM: number }
  | { type: "duplicate-characters"; hasDuplicates: boolean };

export function getVulnHintFor(spec: VulnerabilitySpec) {
  switch (spec.type) {
    case "exact-length":
      return `Length is ${spec.exactLength}`;
    case "vowel-exact":
      return `Exactly ${spec.vowelCount} vowel${spec.vowelCount === 1 ? "" : "s"}`;
    case "vowel-min":
      return `At least ${spec.minVowels} vowel${spec.minVowels === 1 ? "" : "s"}`;
    case "sum":
      return `Sum is ${spec.sum}`;
    case "duplicate-characters":
      return `${spec.hasDuplicates ? "Has" : "no"} duplicate characters`;
    case "at-least-AM":
      return `At least ${spec.minAM} from A-M`;
  }
}

export function getExactLengthVulnSpec(password: string): VulnerabilitySpec {
  return { type: 'exact-length', exactLength: password.length };
}

export function getVulnerabilitySpecs(password: string) {
  const specs: VulnerabilitySpec[] = [];

  // Vowels - exact is strong
  specs.push({ type: "vowel-exact", vowelCount: vowelCount(password) });
  const minVowels = minVowelCount(password);
  if (minVowels > 0) specs.push({ type: "vowel-min", minVowels });

  // Sum
  specs.push({ type: "sum", sum: sumLetters(password) });

  // Dupes - strong
  specs.push({
    type: "duplicate-characters",
    hasDuplicates: hasDuplicateChars(password),
  });

  // Distribution
  const minAM = atLeastFromAM(password);
  if (minAM > 0) {
    specs.push({ type: "at-least-AM", minAM });
  }

  return specs;
}

export interface Vulnerability {
  spec: VulnerabilitySpec;
  test: (candidate: string) => boolean;
}

// Test functions
const isVowel = (c: string) => "AEIOU".includes(c);
const vowelCount = (s: string) => [...s].filter(isVowel).length;
const hasDuplicateChars = (s: string) => new Set(s).size !== s.length;
const sumLetters = (s: string) =>
  [...s].reduce((sum, ch) => sum + (ch.charCodeAt(0) - 64), 0);

const biasedMin = (exact: number, floor = 1) => {
  if (exact === 0) return 0;
  const r = Math.random();
  const biased = r * r;
  const raw = Math.floor(biased * (exact + 1)); // 0..exact
  return Math.min(exact, Math.max(floor, raw));
};

const minVowelCount = (s: string) => {
  const vowels = vowelCount(s);
  return biasedMin(vowels);
};

const amCount = (s: string) => {
  let count = 0;
  for (const c of s) if (c >= "A" && c <= "M") count++;
  return count;
};
const atLeastFromAM = (s: string) => {
  const exact = amCount(s);
  return biasedMin(exact);
};
/**
  For implementing difficulty:
function minVowelsByTier(exact: number, tier: "cheap" | "mid" | "strong") {
  const loosen = tier === "cheap" ? 3 : tier === "mid" ? 2 : 1;
  return Math.max(0, exact - loosen);
}
 */

export function compileVulnerability(spec: VulnerabilitySpec): Vulnerability {
  switch (spec.type) {
    case "exact-length":
      return { spec, test: (s: string) => s.length === spec.exactLength };
    case "vowel-exact":
      return { spec, test: (s: string) => vowelCount(s) === spec.vowelCount };
    case "vowel-min":
      return { spec, test: (s: string) => minVowelCount(s) >= spec.minVowels };
    case "sum":
      return { spec, test: (s: string) => sumLetters(s) === spec.sum };
    case "duplicate-characters":
      return {
        spec,
        test: (s: string) => hasDuplicateChars(s) === spec.hasDuplicates,
      };
    case "at-least-AM":
      return { spec, test: (s: string) => amCount(s) >= spec.minAM };
  }
}
